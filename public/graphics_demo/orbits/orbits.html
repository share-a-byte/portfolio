<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="utf-8" />
    <title>Single-file Example</title>
    <script src="wrapWebGL2.js"></script>
    <script src="math.js"></script>

    <script id="vert" type="glsl">
      #version 300 es
      layout(location=0) in vec4 position;
      layout(location=1) in vec4 color;
      out vec4 color2;
      uniform mat4 mv;
      uniform mat4 p;
      void main() {
          gl_Position = p * mv * position;
          color2 = color;
      }
    </script>

    <script id="frag" type="glsl">
      #version 300 es
      precision highp float;
      out vec4 fragColor;
      in vec4 color2;
      void main() {
          fragColor = color2;
      }
    </script>

    <!-- Code I don't expect to change. -->
    <script>
      const IlliniBlue = new Float32Array([0.075, 0.16, 0.292, 1]);
      const IlliniOrange = new Float32Array([1, 0.373, 0.02, 1]);
      const IdentityMatrix = new Float32Array([
        1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1,
      ]);

      /**
       * Given the source code of a vertex and fragment shader, compiles them,
       * and returns the linked program.
       */
      function compileShader(vs_source, fs_source) {
        const vs = gl.createShader(gl.VERTEX_SHADER);
        gl.shaderSource(vs, vs_source);
        gl.compileShader(vs);
        if (!gl.getShaderParameter(vs, gl.COMPILE_STATUS)) {
          console.error(gl.getShaderInfoLog(vs));
          throw Error("Vertex shader compilation failed");
        }

        const fs = gl.createShader(gl.FRAGMENT_SHADER);
        gl.shaderSource(fs, fs_source);
        gl.compileShader(fs);
        if (!gl.getShaderParameter(fs, gl.COMPILE_STATUS)) {
          console.error(gl.getShaderInfoLog(fs));
          throw Error("Fragment shader compilation failed");
        }

        const program = gl.createProgram();
        gl.attachShader(program, vs);
        gl.attachShader(program, fs);
        gl.linkProgram(program);
        if (!gl.getProgramParameter(program, gl.LINK_STATUS)) {
          console.error(gl.getProgramInfoLog(program));
          throw Error("Linking failed");
        }

        const uniforms = {};
        for (
          let i = 0;
          i < gl.getProgramParameter(program, gl.ACTIVE_UNIFORMS);
          i += 1
        ) {
          let info = gl.getActiveUniform(program, i);
          uniforms[info.name] = gl.getUniformLocation(program, info.name);
        }
        program.uniforms = uniforms;

        return program;
      }

      /**
       * Sends per-vertex data to the GPU and connects it to a VS input
       *
       * @param data    a 2D array of per-vertex data (e.g. [[x,y,z,w],[x,y,z,w],...])
       * @param loc     the layout location of the vertex shader's `in` attribute
       * @param mode    (optional) gl.STATIC_DRAW, gl.DYNAMIC_DRAW, etc
       *
       * @returns the ID of the buffer in GPU memory; useful for changing data later
       */
      function supplyDataBuffer(data, loc, mode) {
        if (mode === undefined) mode = gl.STATIC_DRAW;

        const buf = gl.createBuffer();
        gl.bindBuffer(gl.ARRAY_BUFFER, buf);
        const f32 = new Float32Array(data.flat());
        gl.bufferData(gl.ARRAY_BUFFER, f32, mode);

        gl.vertexAttribPointer(loc, data[0].length, gl.FLOAT, false, 0, 0);
        gl.enableVertexAttribArray(loc);

        return buf;
      }

      /**
       * Creates a Vertex Array Object and puts into it all of the data in the given
       * JSON structure, which should have the following form:
       *
       * ````
       * {"triangles": a list of of indices of vertices
       * ,"attributes":
       *  [ a list of 1-, 2-, 3-, or 4-vectors, one per vertex to go in location 0
       *  , a list of 1-, 2-, 3-, or 4-vectors, one per vertex to go in location 1
       *  , ...
       *  ]
       * }
       * ````
       *
       * @returns an object with four keys:
       *  - mode = the 1st argument for gl.drawElements
       *  - count = the 2nd argument for gl.drawElements
       *  - type = the 3rd argument for gl.drawElements
       *  - vao = the vertex array object for use with gl.bindVertexArray
       */
      function setupGeomery(geom) {
        var triangleArray = gl.createVertexArray();
        gl.bindVertexArray(triangleArray);

        for (let i = 0; i < geom.attributes.length; i += 1) {
          let data = geom.attributes[i];
          supplyDataBuffer(data, i);
        }

        var indices = new Uint16Array(geom.triangles.flat());
        var indexBuffer = gl.createBuffer();
        gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, indexBuffer);
        gl.bufferData(gl.ELEMENT_ARRAY_BUFFER, indices, gl.STATIC_DRAW);

        return {
          mode: gl.TRIANGLES,
          count: indices.length,
          type: gl.UNSIGNED_SHORT,
          vao: triangleArray,
        };
      }
    </script>

    <!-- All the other code in one big script element. -->
    <script>
      var tetrahedron = {
        triangles: [
          [0, 1, 2],
          [0, 2, 3],
          [0, 3, 1],
          [1, 2, 3],
        ],
        attributes: [
          // position
          [
            [1, 1, 1],
            [-1, -1, 1],
            [-1, 1, -1],
            [1, -1, -1],
          ], // color
          [
            [1, 1, 1],
            [0, 0, 1],
            [0, 1, 0],
            [1, 0, 0],
          ],
        ],
      };

      var octahedron = {
        triangles: [
          [0, 1, 2],
          [0, 2, 3],
          [0, 3, 4],
          [0, 4, 1],
          [5, 1, 4],
          [5, 4, 3],
          [5, 3, 2],
          [5, 2, 1],
        ],
        attributes: [
          // position
          [
            [1, 0, 0],
            [0, 1, 0],
            [0, 0, 1],
            [0, -1, 0],
            [0, 0, -1],
            [-1, 0, 0],
          ], // color
          [
            [1, 0.5, 0.5],
            [0.5, 1, 0.5],
            [0.5, 0.5, 1],
            [0.5, 0, 0.5],
            [0.5, 0.5, 0],
            [0, 0.5, 0.5],
          ],
        ],
      };

      /** Draw one frame */
      function draw(seconds) {
        gl.clearColor(...IlliniBlue); // f(...[1,2,3]) means f(1,2,3)
        gl.clear(gl.COLOR_BUFFER_BIT | gl.DEPTH_BUFFER_BIT);
        gl.useProgram(program);

        gl.bindVertexArray(geom2.vao);

        let m = m4rotY(seconds * Math.PI);
        let v = m4view([0, 8, 15], [0, 0, 0], [0, 1, 0]);

        // SUN - scale = 2
        gl.uniformMatrix4fv(
          program.uniforms.mv,
          false,
          m4mul(v, m, m4scale(2, 2, 2))
        );
        gl.uniformMatrix4fv(program.uniforms.p, false, p);
        gl.drawElements(geom2.mode, geom2.count, geom2.type, 0);

        // EARTH
        let earthOrbit = 4; // seconds
        let earthRevolution = m4rotY((seconds / earthOrbit) * 2 * Math.PI);

        let earthSpin = 0.75; // seconds
        let earthRotation = m4rotY((seconds / earthSpin) * 2 * Math.PI);

        let earthRad = 4;

        let earthAxialTilt = m4rotZ(-0.4);
        gl.uniformMatrix4fv(
          program.uniforms.mv,
          false,
          m4mul(
            v,
            earthRevolution,
            m4trans(earthRad, 0, 0),
            earthAxialTilt,
            earthRotation,
            m4scale(0.8, 0.8, 0.8)
          )
        );
        gl.uniformMatrix4fv(program.uniforms.p, false, p);
        gl.drawElements(geom2.mode, geom2.count, geom2.type, 0);

        // MARS
        let marsOrbit = earthOrbit * 1.9;
        let marsRevolution = m4rotY((seconds / marsOrbit) * 2 * Math.PI);

        let marsSpin = earthSpin * 2.2;
        let marsRotation = m4rotY((seconds / marsSpin) * 2 * Math.PI);

        let marsRad = earthRad * 1.6;

        gl.uniformMatrix4fv(
          program.uniforms.mv,
          false,
          m4mul(
            v,
            marsRevolution,
            m4trans(marsRad, 0, 0),
            earthAxialTilt,
            marsRotation,
            m4scale(0.7, 0.7, 0.7)
          )
        );
        gl.uniformMatrix4fv(program.uniforms.p, false, p);
        gl.drawElements(geom2.mode, geom2.count, geom2.type, 0);

        // TETRAHEDRONS
        gl.bindVertexArray(geom.vao);

        // MOON
        let moonOrbit = 2;
        let moonRevolution = m4rotY((seconds / moonOrbit) * 2 * Math.PI);

        let moonRad = 1.5;

        gl.uniformMatrix4fv(
          program.uniforms.mv,
          false,
          m4mul(
            v,
            earthRevolution,
            m4trans(earthRad, 0, 0),
            moonRevolution,
            m4trans(moonRad, 0, 0),
            m4rotY((-seconds / moonOrbit) * 2 * Math.PI), // MAKE SURE SAME SIDE ALWAYS FACING
            m4scale(0.3, 0.3, 0.3)
          )
        );
        gl.uniformMatrix4fv(program.uniforms.p, false, p);
        gl.drawElements(geom.mode, geom.count, geom.type, 0);

        // PHOBOS
        let phobosOrbit = marsSpin / 3;
        let phobosRad = 1;
        let phobosSize = 0.3;
        let phobosRevolution = m4rotY((seconds / phobosOrbit) * 2 * Math.PI);

        gl.uniformMatrix4fv(
          program.uniforms.mv,
          false,
          m4mul(
            v,
            marsRevolution,
            m4trans(marsRad, 0, 0),
            phobosRevolution,
            m4trans(phobosRad, 0, 0),
            m4rotY((-seconds / phobosOrbit) * 2 * Math.PI),
            m4scale(phobosSize, phobosSize, phobosSize)
          )
        );
        gl.uniformMatrix4fv(program.uniforms.p, false, p);
        gl.drawElements(geom.mode, geom.count, geom.type, 0);

        // DEIMOS
        let demosOrbit = marsSpin * 0.95;
        let demosRad = phobosRad * 2;
        let demosSize = phobosSize / 2;
        let demosRevolution = m4rotY((seconds / demosOrbit) * 2 * Math.PI);

        gl.uniformMatrix4fv(
          program.uniforms.mv,
          false,
          m4mul(
            v,
            marsRevolution,
            m4trans(marsRad, 0, 0),
            demosRevolution,
            m4trans(demosRad, 0, 0),
            m4rotY((-seconds / demosOrbit) * 2 * Math.PI),
            m4scale(demosSize, demosSize, demosSize)
          )
        );
        gl.uniformMatrix4fv(program.uniforms.p, false, p);
        gl.drawElements(geom.mode, geom.count, geom.type, 0);
      }

      // /** Compute any time-varying or animated aspects of the scene */
      function tick(milliseconds) {
        let seconds = milliseconds / 1000;

        draw(seconds);
        requestAnimationFrame(tick);
      }

      /** Resizes the canvas to completely fill the screen */
      function fillScreen() {
        let canvas = document.querySelector("canvas");
        document.body.style.margin = "0";
        canvas.style.width = "100vw";
        canvas.style.height = "100vh";
        canvas.width = canvas.clientWidth;
        canvas.height = canvas.clientHeight;
        canvas.style.width = "";
        canvas.style.height = "";
        if (window.gl) {
          gl.viewport(0, 0, canvas.width, canvas.height);
          window.p = m4perspNegZ(0.1, 30, 1.3, canvas.width, canvas.height);
        }
      }

      /** Compile, link, set up geometry */
      window.addEventListener("load", async (event) => {
        window.gl = document.querySelector("canvas").getContext(
          "webgl2",
          // optional configuration object: see https://developer.mozilla.org/en-US/docs/Web/API/HTMLCanvasElement/getContext
          { antialias: false, depth: true, preserveDrawingBuffer: true }
        );
        let vs = document.querySelector("#vert").textContent.trim();
        let fs = document.querySelector("#frag").textContent.trim();
        window.program = compileShader(vs, fs);
        gl.enable(gl.DEPTH_TEST);

        // SENDING FIGURE TO GPU ONCE
        window.geom = setupGeomery(tetrahedron);
        window.geom2 = setupGeomery(octahedron);

        fillScreen();
        window.addEventListener("resize", fillScreen);
        requestAnimationFrame(tick);
      });
    </script>
  </head>
  <body>
    <canvas width="500" height="500"></canvas>
  </body>
</html>
